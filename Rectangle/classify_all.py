import numpy as np
from Polynomial import Polynomial as P
from general import *
from gen_all import gen_all


def stats_from_all(
        nb_line: int = 1,
        nb_column: int = 1)\
        -> tuple:
    """Génère tous les tas de sables
    Revoie la liste de fréquences des tas récurents et non récurents"""
    max_array = None
    max_weight = 0
    min_array = None
    min_weight = nb_line * nb_column * 3
    test = tas_transition_test(nb_line, nb_column)
    weight_recurrent = np.zeros(nb_line * nb_column * 3 + 1, dtype=np.int64)
    weight_transient = np.zeros(nb_line * nb_column * 3 + 1, dtype=np.int64)
    for tas in gen_all(nb_line):
        weight = tas.sum()
        if is_recurrent(tas, test):
            weight_recurrent[weight] += 1
            if weight < min_weight:
                min_weight = weight
                min_array = tas
        else:
            weight_transient[weight] += 1
            if weight > max_weight:
                max_weight = weight
                max_array = tas
    return nb_line, nb_column, weight_transient, weight_recurrent, max_array, min_array


def present_stat_all(result, transient=True, recurrent=True, cummultive=True, conf_max=False, conf_min=False):
    """Present stats generated by stats_for"""
    nb_line, nb_column, weight_transient, weight_recurrent, max_array, min_array = result
    full_weight = nb_line * nb_column * 3

    # transient stats
    transient_mean = (weight_transient * np.arange(full_weight + 1)).sum() / weight_transient.sum()
    transient_max = np.where(weight_transient > 0)[0].max()
    transient_min = np.where(weight_transient > 0)[0].min()

    if transient:
        #  graphics
        plt.hist(range(full_weight + 1), bins=full_weight, range=(0, full_weight), weights=weight_transient,
                 label='Transient', color='green')
        plt.axvline(transient_mean, color='red', label=f"Moyenne à {round(transient_mean, 1)}")
        plt.legend()
        plt.xlabel('Poids des configurations')
        plt.ylabel("Fréquence d'apparition")
        plt.title(f"Poids des configurations transientes pour une taille de {nb_line}x{nb_column}.\n" +
                  f"({weight_transient.sum()} configurations observées)\n" +
                  f"Min: {transient_min}; Max: {transient_max}")
        plt.show()

    # recurrent stats
    recurrent_mean = (weight_recurrent * np.arange(full_weight + 1)).sum() / weight_recurrent.sum()
    recurrent_max = np.where(weight_recurrent > 0)[0].max()
    recurrent_min = np.where(weight_recurrent > 0)[0].min()

    if recurrent:
        #  graphics
        plt.hist(range(full_weight + 1), bins=full_weight, range=(0, full_weight), weights=weight_recurrent,
                 label='Recurentes', color='blue')
        plt.axvline(recurrent_mean, color='red', label=f"Moyenne à {round(recurrent_mean, 1)}")
        plt.legend()
        plt.xlabel('Poids des configurations')
        plt.ylabel("Fréquence d'apparition")
        plt.title(f"Poids des configurations récurrentes pour une taille de {nb_line}x{nb_column}.\n" +
                  f"({weight_recurrent.sum()} configurations observées)\n" +
                  f"Min: {recurrent_min} (théorique: {2 * (nb_line + nb_column)});\n" +
                  f"Max: {recurrent_max} (théorique: {full_weight})")
        plt.show()

    if cummultive:
        # total
        plt.hist(range(full_weight + 1), bins=full_weight, range=(0, full_weight),
                 weights=list(map(int, (P('1 + x + x ** 2 + x ** 3') ** (nb_line * nb_column)).coefficient.values())),
                 label='Total', color='gray', alpha=0.1)

        # cummulative
        plt.hist(range(full_weight + 1), bins=full_weight, range=(0, full_weight), weights=weight_transient,
                 label='Transient', color='green', alpha=0.3)
        plt.axvline(transient_mean, color='red', label=f"Moyenne transiente à {round(transient_mean, 1)}")
        plt.hist(range(full_weight + 1), bins=full_weight, range=(0, full_weight), weights=weight_recurrent,
                 label='Recurentes', color='blue', alpha=0.3)
        plt.axvline(recurrent_mean, color='red', label=f"Moyenne récurente à {round(recurrent_mean, 1)}")
        plt.legend()
        plt.xlabel('Poids des configurations')
        plt.ylabel("Fréquence d'apparition")
        plt.show()

    if conf_max:
        show(max_array, title=f"Configuration transiente maximale (poids: {max_array.sum()})")

    if conf_min:
        show(min_array, title=f"Configuration recurente minimale (poids: {min_array.sum()})")


present_stat_all(stats_from_all(3, 3), True, True, True, False, False)
