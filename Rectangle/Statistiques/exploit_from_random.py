"""Permet de visualiser et d'exploiter les données générées
avec le code stats_from_random"""
from general import *
import numpy as np
import matplotlib.pyplot as plt
from pickle import Unpickler


def present_stat_random(result, transient=True, recurrent=True, cummultive=True, conf_max=False, conf_min=False):
    """Present stats generated by stats_for"""
    nb_line, nb_column, sample, weight_transient, weight_recurrent, max_array, min_array = result
    full_weight = nb_line * nb_column * 3

    # transient stats
    transient_mean = (weight_transient * np.arange(full_weight + 1)).sum() / weight_transient.sum()
    transient_max = np.where(weight_transient > 0)[0].max()
    transient_min = np.where(weight_transient > 0)[0].min()

    if transient:
        #  graphics
        plt.hist(range(full_weight + 1), bins=full_weight, range=(0, full_weight), weights=weight_transient,
                 density=1, label='Transient', color='green')
        plt.axvline(transient_mean, color='red', label=f"Moyenne à {round(transient_mean, 1)}")
        plt.legend()
        plt.xlabel('Poids des configurations')
        plt.ylabel("Nombre d'apparitions")
        plt.title(f"Poids des configurations transientes pour une taille de {nb_line}x{nb_column}.\n" +
                  f"({weight_transient.sum()} configurations observées)\n" +
                  f"Min: {transient_min}; Max: {transient_max}")
        plt.show()

    # recurrent stats
    recurrent_mean = (weight_recurrent * np.arange(full_weight + 1)).sum() / weight_recurrent.sum()
    recurrent_max = np.where(weight_recurrent > 0)[0].max()
    recurrent_min = np.where(weight_recurrent > 0)[0].min()

    if recurrent:
        #  graphics
        plt.hist(range(full_weight + 1), bins=full_weight, range=(0, full_weight), weights=weight_recurrent,
                 label='Recurrentes', color='blue')
        plt.axvline(recurrent_mean, color='red', label=f"Moyenne à {round(recurrent_mean, 1)}")
        plt.legend()
        plt.xlabel('Poids des configurations')
        plt.ylabel("Nombre d'apparitions")
        plt.title(f"Poids des configurations récurrentes pour une taille de {nb_line}x{nb_column}.\n" +
                  f"({weight_recurrent.sum()} configurations observées)\n" +
                  f"Min: {recurrent_min} (théorique: {2 * (nb_line + nb_column)});\n" +
                  f"Max: {recurrent_max} (théorique: {full_weight})")
        plt.show()

    if cummultive:
        # cummulative
        plt.hist(range(full_weight + 1), bins=full_weight, range=(0, full_weight), weights=weight_transient,
                 label='Transient', color='green', alpha=0.3)
        plt.axvline(transient_mean, color='red', label=f"Moyenne transiente à {round(transient_mean, 1)}")
        plt.hist(range(full_weight + 1), bins=full_weight, range=(0, full_weight), weights=weight_recurrent,
                 label='Recurrentes', color='blue', alpha=0.3)
        plt.axvline(recurrent_mean, color='red', label=f"Moyenne récurrente à {round(recurrent_mean, 1)}")
        plt.hist(range(full_weight + 1), bins=full_weight, range=(0, full_weight), weights=weight_recurrent + weight_transient,
                 label='Somme', color='gray', alpha=0.3)
        plt.legend()
        plt.xlabel('Poids des configurations')
        plt.ylabel("Nombre d'apparitions")
        plt.show()

    if conf_max:
        show(max_array, title=f"Configuration transiente maximale (poids: {max_array.sum()})")

    if conf_min:
        show(min_array, title=f"Configuration recurente minimale (poids: {min_array.sum()})")


def present_from_load(nb_line, nb_column, sample, transient=True, recurrent=True, cummultive=True, conf_max=False, conf_min=False):
    """Present stats saved"""
    with open(f"Data\Random\\random_{nb_line}_{nb_column}_{sample}", 'rb') as file:
        pic = Unpickler(file)
        present_stat_random(pic.load(), transient, recurrent, cummultive, conf_max, conf_min)


if __name__ == '__main__':
    present_from_load(5, 5, 10000000)
